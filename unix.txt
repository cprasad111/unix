##Count lines, words, characters
	wc <fileName>
	wc <file1> <file2> …… <fileN>
	
##output and error redirect
	echo "a" > output.txt 2> error.txt  (output and error to different file)
	echo "a" > output.txt 2>&1 (output and error to same file)
	
	
##permission
	u: user
	g: group
	o: others
	+: add permission
	-: remove permission
	=: grant permission
	absolute permission
	read(4), write(2), execute(1)
	chmod u+x <file1>   (add execute permission to user)
	chmod o-wx <file1> (removes write and execute permission to others)
	
##Shell
	when a user login to unix, the shell goes through initialization by reading /etc/profile file and user specific .profile file
	
##grep
	-v: not match
	-n: prints line number
	-l: prints only the files
	-L: prints only the files that don't match
	-i: ignore case
	-c: prints the count of matching lines
	-A: prints n lines after matching
	grep -A 3 string file 9 (prints matching line and 3 lines after the matching line)
	
	
##sort
	-n: sort numerically
	-r: descending to ascending
	+x: ignores first x files while sorting
		a. 
		sort by 4 field in ls -rlth
		ls -rlth | sort +4
	
##vi
	a: append
	A: append to the end of line
	i: insert
	I: insert at the beginning of line
	o: insert a line below
	O: insert a line above
	
##script arguments
	$0: filename
	$1: first argument
	$2: 2nd argument and so on
	$#: number of argument
	$*: list of all arguments (can loop over arguments using this)
	$?: exit status for last command

##array
	
##maths
	echo `expr 2 + 2`  (output 4, separate numbers and + sign with space)
	expr $a - $b
	expr $a \* $b
	expr $a / $b
	expr $a % $b
	[ $a == $b ]
	[ $a != $b ]
		○ Following operators only for numeric
		-eq -ne -gt -lt -ge -le
##Conditions
	a=10
	b=20
	
	if [ $a -eq $b ]
	then
	    echo "$a and $b are equal"
	elif [ $a -gt $b ]
	then
	    echo "$a is greater than $b"
	elif [ $a -lt $b -a $a -eq 100 ]
	then
	    echo "$a is smaller than $b and a = 10"
	elif [ $a -lt $b -o $a -ne 10 ]
	then
	    echo "$a is less than $b or a is equal to 10"
	else
	    echo "done"
	fi
	
##Loops
	while <condition>
	do
	    command1
	    command2
	done
	
	
	for x in 1 2 3
	do
	   echo $x
	done
	
##variable substitution
	${var:=word} - if var is null or unset, it's assigned word
	there are others as well
	
##input to a command
	command << delimiter
	document
	delimiter
	
	#Here the shell interprets the << operator as an instruction to read input until it finds a line containing the specified delimiter
	
	
	
	$ wc << ABC
	> This is a text
	> This is another text 2
	> ABC
	 2  9 38
	
##function
	#!/bin/sh
	# Define your function here
	Hello () {
		echo "Hello World $1 $2"
		return 10
	}
	
	# Invoke your function
	Hello Zara Ali
	
	# Capture value returnd by last command
	ret=$?
	
	#output
	Hello World Zara Ali
	Return value is 10
	
	
##sed
	#search and replace (only the first occurence in each line is replaced
	sed 's/search_string/replace_string/' file > outputFile
	
	#search and replace all occurence in each line
	sed 's/search_string/replace_string/g' file > outputFile
	
	#sed to delete
	sed '2d' <file> | more #deletes the second line and displays the output. The actual file is not edited
	sed '1,3d' <file> | more #deletes line from 1 to 3 and print. The actual file is not edited
	'1,+5d': deletes line 1 and next 5 lines
	
	sed '2,4!d' <file> deletes everything except the line 2 to 4
	
	sed '/^daemon/d' <file> #deletes all the lines starting with daemon
	
	#sed to print
	sed '2,4p' <file>  # print all lines of files and 2 to 4 line numbers are printed twice
	sed -n '2,4p' <file> # only prints line 2 to 4
	
	

##awk
##find
	#find files/folders by name
	find . -name "searchFileName" -print

	#executes command on files/folderes found by find command
	find . -name "searchFileName" -exec "command" {} \;
	find . -name "searchFileName" -exec "ls" {} \;  #lists files in the folders that are searched, files that are searched
	
	#-type f and d for files and directories
	find . -type f -name "search"  # searches only files
	find . -type d -name "search"  # searches only directories
	
	#run grep on all files
	find . -type f -name '*put*' -exec grep '4' {} \;
	find . -type f -name '*put*' | xargs grep 'q'

##cut
	#cut by byte (counting from 1)
	echo baz | cut -b 2
	output: b
	
	echo baz | cut -b 1-2
	output: ba
	
	echo baz | cut -b 1,3
	output: bz
	
	#if there is a multibyte character, it's better to use
	#cut by character
	same as above
	
	#cut by delimiter
	echo a,b,c,d | cut -d ',' -f 1
	output: a
	
	echo a,b,c,d | cut -d ',' -f 1-3
	a,b,c
	
	#print that is not cut by the command
	echo a,b,c,d | cut --complement -d ',' -f 1
	output: b,c,d
	
	#if a file is give, the operations is run on each line
	cut -d ',' -f 1 <fileName>
	
	#change output delimiter. Delimiter can be any character or combination of characters
	echo 'how;now;brown;cow' | cut -d ';' -f 1,3,4 --output-delimiter=','
	output; how,brown,cow

	

